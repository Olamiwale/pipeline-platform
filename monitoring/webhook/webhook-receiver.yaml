
# Webhook-receiver ConfigMap (server.py). it houses the actual Flask app code that the Deployment mounts and executes.

#Functions: 
#verify_signature(): Confirms the webhook request came from GitHub (not spoofed).
#/webhook route: Receives, validates, and processes GitHub event payloads.


#Usefulness: 
#It’s the bridge between GitHub Actions → Kubernetes Monitoring, letting your CI/CD cluster respond to workflow results in real-time.

apiVersion: v1
kind: ConfigMap
metadata:
  name: webhook-receiver
  namespace: cicd
data:
  server.py: |
    from flask import Flask, request, jsonify
    import hmac
    import hashlib
    import os
    
    app = Flask(__name__)
    WEBHOOK_SECRET = os.environ.get('WEBHOOK_SECRET', '')
    
    def verify_signature(payload, signature):
        mac = hmac.new(WEBHOOK_SECRET.encode(), payload, hashlib.sha256)
        return hmac.compare_digest('sha256=' + mac.hexdigest(), signature)
    
    @app.route('/webhook', methods=['POST'])
    def webhook():
        signature = request.headers.get('X-Hub-Signature-256')
        
        if not verify_signature(request.data, signature):
            return jsonify({'error': 'Invalid signature'}), 403
        
        event = request.headers.get('X-GitHub-Event')
        payload = request.json
        
        # Handle different events
        if event == 'workflow_run':
            print(f"Workflow: {payload['workflow_run']['name']}")
            print(f"Status: {payload['workflow_run']['conclusion']}")
            print(f"Duration: {payload['workflow_run']['run_duration_ms']}ms")
        
        return jsonify({'status': 'received'}), 200
    
    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=8080)




